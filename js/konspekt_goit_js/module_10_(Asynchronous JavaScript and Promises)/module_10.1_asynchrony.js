//Асинхронність

// #region Асинхронні операції
// Весь код виконується процесором твого комп'ютера.
// Код, який ми писали досі, був синхронним, тобто займав процесор на весь час свого виконання. Так, швидкість виконання циклу для ітерації по масиву залежить від швидкості процесора.

// Є операції, які взаємодіють із зовнішнім світом, наприклад: обмін даними із сервером у мережі. Це набагато повільніше, ніж отримання даних із пам'яті. Якщо такі операції обробляються синхронно, то процесор простоює під час мережевого запиту до сервера, замість того, щоб виконувати інший код.

// Синхронний код виконується послідовно, кожна інструкція очікує, доки виконається попередня. Коли ти викликаєш функцію, яка виконує тривалу дію, це зупиняє програму на увесь час її виконання. Тобто в моделі синхронного програмування все відбувається по черзі.
// Уяви чергу придбання квитків на потяг. Ти не можеш почати купувати квиток доти, доки квиток не придбає людина перед тобою. Так само люди, які стоять за тобою, не можуть почати купувати квитки доти, доки ти не придбаєш.

// В асинхронному коді одночасно можуть виконуватися декілька операцій. У такій моделі мережевий запит на сервер не зупинить програму, вона продовжить виконувати інші операції. Коли запит завершиться, програма повідомляє про це й отримує доступ до результату (наприклад, даних із сервера).
// Уяви обід в ресторані. Ти та інші відвідувачі замовляєте їжу. Тобі не потрібно чекати, доки їм принесуть їжу, перш ніж замовляти. Так само інші відвідувачі не повинні чекати, доки ти отримаєш свою страву і поїси, перш ніж вони зможуть замовити. Кожен отримає свою страву, щойно її завершать готувати.

//Розглянемо різницю на прикладі, у якому програма виконує два мережеві запити на сервер, після чого обробляє їх результат.
// Операції 1 і 2 — це функції, які роблять запити на сервер.
// Операції 3, 4 і 5 — будь-який інший звичний для тебе код

// У синхронній моделі все зрозуміло — попередні операції блокують виконання наступних, доки вони не завершаться. Якщо операції 3, 4 і 5 — це обробка кліків користувача, то інтерфейс просто зависне, доки не будуть виконані й оброблені результати запитів 1 і 2.
// Уявімо, що користувач відправив коментар (мережевий запит) і водночас захотів відкрити сайдбар з останніми новинами. Після кліка відправити коментар, інтерфейс зависне і не буде реагувати на його дії, доки від сервера не прийде результат відправлення коментаря. Погодься, це не дуже зручно.

// В асинхронній моделі старт мережевого запиту викликає щось на зразок розгалуження, тобто запуск запиту і результат його обробки — це різні дії. Доки виконується запит, програма продовжує працювати й виконувати інший код. Щойно мережевий запит буде виконаний, програма може почати обробляти його результат одразу після звільнення. Це означає, що користувач відправив коментар і відразу зміг відкрити сайдбар зі свіжими новинами, не чекаючи, доки прийде відповідь від сервера.
// За одиницю часу, як і раніше, може виконуватися тільки одна операція, тому що JavaScript — однопотокова мова. Асинхронне програмування досягається шляхом відкладених викликів функцій, де ініціалізація асинхронної операції і обробка її результату — це різні дії.

//#endregion

//#region Асинхронний код
// У синхронному коді інструкції обробляються послідовно. Отже, наступна інструкція не може почати своє виконання, доки не виконається попередня.

console.log("First log");
console.log("Second log");
console.log("Third log");
//У консолі будуть три послідовні повідомлення в тому порядку, в якому відповідні функції console.log() були викликані.

//Код нижче — асинхронний. З функцією setTimeout() ми познайомимося далі. Зараз про неї нам потрібно знати тільки те, що вона приймає два параметри:
// callback-функцію, яка буде викликана після закінчення часу;
// час, після якого буде викликана функція.
{
  // Виконується першою
  console.log("First log");

  setTimeout(() => {
    // Виконується третьою, через 2000 мілісекунд (2 секунди)
    console.log("Second log");
  }, 2000);

  // Виконується другою
  console.log("Third log");
}

//Функція setTimeout() відпрацьовує синхронно й реєструє відкладений виклик переданої callback-функції. Ця функція буде викликана асинхронно, через вказаний проміжок часу.
// Хоча маємо 3 різні команди console.log(), їх порядок виводу може бути не відповідним послідовності коду через асинхронну природу setTimeout().F

//Послідовність подій:
// Виконується синхронний console.log("First log");, і в консоль виводиться "First log".
// Виконується setTimeout(), який синхронно ставить передану функцію в асинхронну чергу на виконання. Але через вказану затримку в 2000 мілісекунд (2 секунди), виконання цієї функції відкладається на цей час.
// Виконується синхронний console.log("Third log");, і в консоль виводиться "Third log".
// Після 2 секунд виконується асинхронний виклик функції, переданої в setTimeout(), і в консоль виводиться "Second log".
//#endregion

//#region Багатопотоковість
// Не плутай асинхронність і багатопотоковість (паралелізм) — це різні моделі програмування. Наведемо просту аналогію, яка все розставить на свої місця. Уяви, що ти шеф у ресторані, і надходить замовлення на каву і тости.Синхронний однопотоковий підхід — ти сам спочатку готуєш каву, потім тости і подаєш їх, після чого прибираєшся на кухні.

// Асинхронний однопотоковий підхід —- ти починаєш готувати каву і встановлюєш таймер, потім починаєш готувати тости і так само встановлюєш таймер. Доки кава і тости готуються, ти прибираєш на кухні. Коли таймери спрацьовують, ти знімаєш з вогню каву, дістаєш тости і подаєш їх.
// Багатопотоковий підхід (паралелізм) — ти наймаєш двох помічників. Одного — для приготування кави, а іншого — для тостів. Тепер у тебе є проблема управління помічниками (потоками), щоб вони не конфліктували один з одним на кухні під час спільного використання ресурсів.

// В асинхронних однопотокових процесах у тебе є графік завдань, в якому деякі завдання залежать від результату роботи інших. З виконанням кожного завдання викликається код для обробки його результату.
//#endregion

//#region Тайм-аут
// Внутрішній таймер-планувальник браузера дозволяє відкладати виклик функції на певний період часу. Для цього є тайм-аути та інтервали, вони контролюють, коли і як часто викликається функція. Таймери реалізовані в браузері, а не вбудовані в мову, і доступні на глобальному об'єкті window.

//Метод setTimeout() дозволяє запланувати одноразовий виклик функції через певний час.

//const timerId = setTimeout(callback, delay, arg1, arg2, ...);

//callback — функція, виклик якої необхідно запланувати;
// delay — час у мілісекундах, через який callback-функція буде викликана один раз.
// Додаткові аргументи (arg1, arg2 тощо) не обов’язкові і будуть передані callback функції під час виклику. Результатом виклику setTimout() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.

{
  //У прикладі коду нижче через дві секунди після натискання на кнопку в консолі розробника з'явиться повідомлення, вказане в колбек-функції для setTimeout. При кожному натисканні на кнопку буде запускатися новий таймер, якому буде присвоюватися новий числовий ідентифікатор.

  const button = document.querySelector("button");

  const onClick = () => {
    const timerId = setTimeout(() => {
      console.log("I love async JS!");
    }, 2000);

    console.log(timerId);
  };

  button.addEventListener("click", onClick);
}
//#endregion

//#region Скасування тайм-ауту

// Якщо з якихось причин нам потрібно скасувати відкладений виклик функції, зареєстрованої тайм-аутом, використовується метод clearTimeout(id).
// Метод clearTimeout(id)приймає ідентифікатор таймера та “очищає його”, тобто видаляє реєстрацію відкладеного виклику функції з черги.

{
  //У цьому прикладі ми додали кнопку скасування таймера «Clear timeout».

  const setBtn = document.querySelector(".js-set");
  const clearBtn = document.querySelector(".js-clear");
  let timeoutId;

  setBtn.addEventListener("click", () => {
    timeoutId = setTimeout(() => {
      console.log("I love async JS!");
    }, 2000);
  });

  clearBtn.addEventListener("click", () => {
    clearTimeout(timeoutId);
    console.log(`Timeout with id ${timeoutId} has stopped!`);
  });
}
//Кожного разу при натисканні на кнопку Set timeout буде створюватися новий таймер, якому буде присвоєно новий ідентифікатор.
// Натискання на кнопку Clear timeout очистить відповідний таймер за переданим числовим ідентифікатором.
// Якщо потрібно очищати всі таймери, можна, наприклад, зберігати ідентифікатори всіх запущених таймерів у вигляді масиву, перебирати його та послідовно очищати.
//#endregion

//#regionІнтервал
// Метод setInterval() — це простий спосіб повторення коду знову і знову з певним інтервалом.

// Синтаксис і параметри такі самі, як у setTimeout().
//const intervalId = setInterval(callback, delay, arg1, arg2, ...);

//Результатом виклику setInterval() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.
// На відміну від setTimeout(), інтервал запускає виконання функції не один раз, а регулярно повторює її через вказаний проміжок часу.
// Щоразу при натисканні на кнопку Start буде створюватися новий інтервал, якому буде присвоєно новий числовий ідентифікатор.

{
  //У прикладі будемо кожну секунду виводити в консоль рядок. Використовуємо Math.random(), щоб рядки були різні.

  const startBtn = document.querySelector(".js-start");

  startBtn.addEventListener("click", () => {
    const intervalId = setInterval(() => {
      console.log(`Interval ID: ${intervalId}, ${Math.random()}`);
    }, 1000);
  });
}

//У браузерного таймера є мінімально можлива затримка, вона коливається приблизно від 0 до 4 мілісекунд. За стандартом, мінімальна затримка становить 4 мілісекунди, тому різниці між setInterval(cb, 1) і setInterval(cb, 4) немає.
// Таймер може спрацьовувати рідше, ніж зазначено в параметрі delay. Адже через занадто велике завантаження процесора деякі запуски функцій-інтервалів будуть пропущені. Браузери продовжують виконувати тайм-аути та інтервали, навіть якщо вкладка браузера неактивна, але водночас знижується частота спрацьовування таймерів.
//#endregion

//#region Скасування інтервалу
// Якщо з якихось причин нам потрібно скасувати виконання функції, зареєстрованої інтервалом, використовується метод clearInterval
// Він приймає ідентифікатор інтервалу та очищає його, тобто видаляє виклики, зареєстровані переданим інтервалом з асинхронної черги.
{
  // У живому прикладі ми додали кнопку скасування інтервалу Stop, клікаючи на неї ми викличемо clearInterval() і передамо ідентифікатор інтервалу, який потрібно зупинити.
  const startBtn = document.querySelector(".js-start");
  const stopBtn = document.querySelector(".js-stop");
  let intervalId = null;

  startBtn.addEventListener("click", () => {
    intervalId = setInterval(() => {
      console.log(`Interval ID: ${intervalId}, ${Math.random()}`);
    }, 1000);
  });

  stopBtn.addEventListener("click", () => {
    clearInterval(intervalId);
    console.log(`Interval with id ${intervalId} has stopped!`);
  });
}
//#endregion
