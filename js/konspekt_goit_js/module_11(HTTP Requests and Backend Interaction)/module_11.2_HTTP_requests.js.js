//#region HTTP-запити
/*
Сервер — це комп’ютер із спеціальним програмним забезпеченням, який приймає та обробляє запити від інших пристроїв у мережі.

Бекенд — це програма, що працює на сервері, яка:

Приймає вхідні HTTP-запити.
Обробляє дані та виконує необхідні дії.
Надсилає відповідь клієнту у вигляді даних (наприклад, у форматі JSON). 



API (інтерфейс прикладного програмування) — набір чітко визначених правил, які визначають, що можна попросити програму зробити і що буде в результаті.

REST API — це бекенд, побудований за принципами REST (Representational State Transfer). Ця архітектура визначає:

Як називаються та адресуються ресурси.
Як клієнт може взаємодіяти з ними через HTTP-запити.
REST API виконує роль посередника між вебзастосунком і базою даних:

Клієнт надсилає HTTP-запит.
Сервер обробляє його та повертає JSON-відповідь, а не HTML-сторінку.
REST API мають єдину логіку роботи, тому після розуміння принципів їх використання залишається лише читати документацію конкретного бекенду. Це універсальний підхід, що дозволяє легко працювати з різними сервісами.
*/

//#endregion

//#region Шлях до ресурсу
/* 
Запити на бекенд повинні містити шлях до ресурсу, над яким виконується операція. Доступні шляхи (ендпоінти) описуються в документації бекенду. 

Ендпоінти (англ. endpoints) у вебсервісах та API — це конкретні URL-адреси, через які можна отримати доступ до певних функцій або ресурсів сервера. Вони дозволяють:

Отримувати дані.
Надсилати нові дані.
Оновлювати або видаляти існуючі записи.


Давай розберемо це на прикладі JSONPlaceholder API. Це публічний REST API, який надає тестові дані.
https://jsonplaceholder.typicode.com/users

Цей шлях є ієрархічним та описовим, навіть якщо ми ніколи раніше його не бачили. Він складається з двох основних частин:

https://jsonplaceholder.typicode.com — базовий URL, точка входу в API.
/users — ресурс, до якого ми звертаємося (у цьому випадку список користувачів).


Як перевірити відповідь API?

Скопіюй цей шлях та встав у адресний рядок браузера.
Браузер виконає HTTP-запит.
У відповідь прийде JSON-об'єкт із даними (замість HTML-сторінки).


Таким чином, REST API працює як вебсайт, але повертає не сторінки, а структуровані дані у форматі JSON (див. схему).
*/
//#endregion

//#region Fetch API
/* 
Fetch API — це вбудований у браузер інтерфейс, доступний через об'єкт window. Він дозволяє відправляти HTTP-запити на сервер і обробляти відповіді.

Метод fetch() забезпечує сучасний підхід до роботи з мережею та побудований на промісах.
fetch(url, options)
url — шлях до ресурсу на сервері (обов’язковий параметр).
options — об’єкт із додатковими налаштуваннями запиту (наприклад, метод, заголовки, тіло тощо).

JSONPlaceholder API — це тестовий REST API, який містить колекції фіктивних даних, наприклад список користувачів (/users).

fetch("https://jsonplaceholder.typicode.com/users")
  .then(response => {
    // Response handling
  })
  .then(data => {
    // Data handling
  })
  .catch(error => {
    // Error handling
  });

Як працює цей код?

fetch() відправляє запит на сервер і повертає проміс.
then(response => {...}) виконується, коли відповідь отримано.
then(data => {...}) обробляє отримані дані.
catch(error => {...}) виконується у разі помилки.
 */
//#endregion

//#region Вкладка Network
/* 
Вкладка Network (укр. “Мережа”) в інструментах розробника дозволяє переглядати всі HTTP-запити, що виконуються на сторінці. Вона корисна для перевірки деталей запитів до бекенду.

Як переглянути запити в Network?

Відкрий вкладку Network в інструментах розробника (Chrome: F12 або Ctrl + Shift + I).
Обери фільтр XHR або Fetch/XHR, щоб бачити лише асинхронні HTTP/HTTPS-запити (fetch, XMLHttpRequest).
Виконай код із fetch() або запусти скрипт, що робить HTTP-запит.
У списку з’явиться запит — натисни на нього, щоб переглянути детальну інформацію.
Відкрий відповідні підвкладки:
Headers (укр. “Заголовки”) — показує всі відправлені заголовки та параметри.
Preview (укр. “Попередній перегляд”) — показує зручне відображення відповіді сервера.
Response (укр. “Відповідь”) — показує сирі дані, отримані від сервера.

Чому це корисно?

Дозволяє відстежувати всі запити вебсторінки.
Дає змогу перевірити, чи правильно сформований запит.
Допомагає виявляти помилки в мережевих запитах.

Використання вкладки Network — один із основних інструментів налагодження вебзапитів у браузері.

*/
//#endregion

//#region Коди відповідей
/* 

На запит клієнта сервер відправляє відповідь, яка містить код стану, щоб інформувати клієнта про результат операції.

Код відповіді можна подивитися на вкладці Network у полі Status Code.

Коди діляться на групи залежно від того, з якої цифри починається код помилки.

1XX — мають інформаційне призначення
2XX — коди успішного проведення операції
3XX — описують усе, що пов'язано з перенаправленням (redirect)
4XX — вказують на помилки з боку клієнта
5XX — вказують на помилки з боку сервера

Немає потреби пам'ятати всі коди з кожної групи, достатньо знати найпоширеніші. Решту завжди можна подивитися в довіднику HTTP-кодів.

200 (OK) — стандартна відповідь для успішних HTTP-запитів.
201 (Created) — стандартна відповідь для HTTP-запиту, який привів до успішного створення ресурсу.
400 (Bad Request) — запит не може бути оброблений через неправильний синтаксис запиту або іншу помилку клієнта.
401 (Unauthorized) — для доступу до ресурсу вимагається авторизація.
403 (Forbidden) — у клієнта немає дозволу на доступ до цього ресурсу.
404 (Not Found) — у цей час ресурс не знайдений. Можливо, він був видалений або ще не існує.
500 (Internal Server Error) — загальна відповідь на непередбачений збій сервера, якщо відсутня конкретніша інформація.

*/
//#endregion

//#region Перевірка відповіді
/* 

Метод fetch() повертає проміс, значенням якого є об'єкт Response. Це службовий об'єкт, що містить інформацію про стан відповіді сервера та методи для обробки отриманих даних.


Залежно від типу контенту використовуються різні методи для перетворення даних у зручний формат:

json() — парсить відповідь у форматі JSON.
text() — парсить відповідь у вигляді тексту (наприклад табличні дані, .csv).
blob() — використовується для обробки файлів (зображення, аудіо, відео).

За замовчуванням fetch() не вважає HTTP-коди 404 чи 500 помилками. Тому потрібно вручну перевіряти статус відповіді та створювати помилку для обробки в catch().

fetch("https://jsonplaceholder.typicode.com/users")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    // Data handling
		console.log("Отримані дані:", data);
  })
  .catch(error => {
    // Error handling
		console.log("Помилка запиту:", error);
  });

Чому це важливо?

fetch() не відхиляє проміс при помилках сервера (наприклад, 404 або 500).
Щоб виявити невдалий запит, потрібно вручну перевіряти response.ok.
Якщо response.ok === false, необхідно викликати throw new Error(), щоб помилка оброблялася в catch().


Такий підхід дозволяє коректно реагувати на помилки та уникати несподіваної поведінки в коді.

*/
//#endregion

//#region HTTP-методи
/* 

У REST API використовується кілька основних HTTP-методів для взаємодії з ресурсами:

POST — створює новий ресурс.
GET — отримує набір ресурсів або один ресурс.
PUT — оновлює існуючий ресурс або створює новий.
PATCH — частково оновлює існуючий ресурс.
DELETE — видаляє ресурс.

Наразі нас цікавить GET, який використовується для отримання даних із сервера.

Метод запиту задається через об’єкт налаштувань, який передається другим аргументом у fetch():

const options = {
	method: "GET"
};

fetch("https://jsonplaceholder.typicode.com/users", options)
  .then(response => {
    if (!response.ok) {
      throw new Error(response.status);
    }
    return response.json();
  })
  .then(data => {
    // Data handling
  })
  .catch(error => {
    // Error handling
  });

Важливі нюанси

Якщо виконується GETзапит, вказувати method: "GET" не обов’язково, оскільки це значення за замовчуванням.
Доступні HTTP-методи для кожного ресурсу описані у документації бекенду.

Використання правильного HTTP-методу гарантує, що сервер обробить запит очікуваним чином.

 */
//#endregion

//#region HTTP-заголовки
/* 

HTTP-заголовки містять службову інформацію, що описує запит або відповідь. Кожен заголовок складається з імені та значення. Наприклад:

Accept — визначає тип контенту, який клієнт може прийняти у відповіді.
Content-Type — вказує тип контенту, щоб отримувач знав, як його обробити.

Accept: text/html
Content-Type: application/json

Заголовок складається з імені та значення. Значення заголовка — це MIME-тип (тип контенту), який використовується для вказівки типу контенту запиту чи відповіді і складається з типу і підтипу, розділених косою рискою (/).

Наприклад:

text/html — HTML-файл.
text/css — CSS-файл.
application/json — JSON-дані.

Якщо клієнт очікує text/css, а отримує application/json, він не зможе правильно обробити відповідь. Тому заголовки допомагають серверу і клієнту погоджувати формат переданих даних.

Як переглянути заголовки у браузері?
У вкладці Network (інструменти розробника) заголовки відповіді видно в секції Response Headers, а заголовки запиту — у Request Headers.


Як передати заголовки у fetch()?
Заголовки додаються у властивість headers об’єкта налаштувань:

fetch("some-url", {
	headers: {
	  "Content-Type": "application/json",
	  "X-Custom-Header": "custom value",
	}
})


Якщо потрібно вказати, що ми очікуємо відповідь у форматі JSON, додаємо Accept: application/json:
fetch("https://jsonplaceholder.typicode.com/users", {
  headers: {
    Accept: "application/json",
  },
}).then(response => {
  // ...
});


Стандартні заголовки

Сучасні браузери автоматично додають деякі заголовки, тому їх не потрібно вказувати вручну. Ось найпоширеніші з них:

User-Agent — ідентифікує браузер або інший клієнтський застосунок.
Accept — вказує, які формати даних клієнт може обробляти.
Content-Type — вказує тип контенту в тілі запиту або відповіді.
Authorization — використовується для передачі токенів аутентифікації.
Cache-Control — керує кешуванням відповіді.
Host — містить доменне ім’я сервера, до якого виконується запит.


Заголовки відіграють ключову роль у взаємодії клієнта та сервера, дозволяючи налаштовувати формат переданих даних і механізми автентифікації.

*/
//#endregion

//#region Кросдоменні запити
/* 

За замовчуванням браузери дозволяють виконувати HTTP-запити тільки в межах поточного сайту. Якщо запит робиться на інший домен, порт або протокол, браузер блокує його та видає помилку.

Ця політика безпеки називається CORS (Cross-Origin Resource Sharing), що перекладається як "спільне використання ресурсів між різними джерелами".

Як працює CORS?
При кожному HTTP-запиті браузер автоматично додає заголовок Origin, де вказує адресу вебсторінки, яка намагається отримати дані.

Приклад запиту з вебсторінки https://my-site.com/about на сервер https://my-api.com/users
GET /users
Host: my-api.com
Origin: https://my-site.com

Сервер перевіряє заголовок Origin і, якщо він дозволяє кросдоменні запити, додає у відповідь спеціальний заголовок Access-Control-Allow-Origin.
# Доступ тільки для одного сайту
Access-Control-Allow-Origin: https://my-site.com

# Доступ для всіх (публічний API)
Access-Control-Allow-Origin: *

Як сервер обробляє CORS?

Якщо Access-Control-Allow-Origin містить конкретний сайт, тільки він може отримати відповідь.
Якщо значення *, запити дозволені з будь-якого джерела.
Якщо цей заголовок відсутній, браузер блокує відповідь, і JavaScript-код отримає помилку CORS.


Браузер виступає посередником між JavaScript-кодом і сервером:

Додає заголовок Origin до запиту.
Перевіряє відповідь сервера на наявність Access-Control-Allow-Origin.
Якщо заголовок присутній і збігається — запит виконується успішно.
Якщо ні — браузер блокує відповідь і викидає помилку CORS.


Висновок

CORS налаштовується на бекенді. Якщо сервер не підтримує кросдоменні запити, фронтенд-розробник не може змінити це у своєму коді. Якщо при виконанні запиту виникає помилка CORS, необхідно перевірити налаштування бекенду та дозволи на доступ.

*/
//#endregion
