//Синтаксис async/await

//#region Асинхронні функції

//Синтаксис async/await — це зручний спосіб написання асинхронного коду, який виглядає схожим на синхронний. Цей підхід був доданий у стандарт ECMAScript 2017 (ES8) і став популярним серед розробників завдяки простоті та зрозумілості.

//Будь-яка функція може бути асинхронною, якщо перед її оголошенням додати ключове слово async.

// Для оголошення асинхронної функції перед ключовим словом function додається async.
async function fetchData() {
  // ...
}

//У функціональному виразі також перед ключовим словом function додається async.
{
  const fetchData = async function () {
    // ...
  };
}

//Для оголошення асинхронної стрілкової функції перед списком параметрів додається ключове слово async.
{
  const fetchData = async () => {
    // ...
  };
}

//Для оголошення асинхронного методу об'єкта async додається перед іменем методу.
const user = {
  async getUsername() {
    // ...
  },
};

//Для оголошення асинхронного методу об'єкта async додається перед іменем методу.
{
  const user = {
    async getUsername() {
      // ...
    },
  };
}

//Для оголошення асинхронного методу класу також використовується async перед іменем методу.
{
  class User {
    async getUsername() {
      // ...
    }
  }
}

//Асинхронні функції дозволяють працювати з await, що робить код чистішим та легшим для розуміння, усуваючи необхідність у вкладених .then().
//#endregion

//#region Значення, що повертається

//Синтаксис async/await базується на промісах, тому не блокує основний потік виконання програми. Це альтернатива підходу з then/catch для роботи з асинхронним кодом.

/* 
Що повертає асинхронна функція?

Завжди повертає проміс.
Якщо функція повертає значення, воно обгортається в проміс.
Якщо не повертає значення, створюється проміс із undefined.
 */

//Отже, будь-яке значення, що повертається з функції, стане значенням проміса.
{
  const foo = async () => {
    return 5;
  };

  foo().then((value) => {
    console.log(value); // 5
  });
  //Функція foo() повертає 5, але фактично це Promise.resolve(5).
}

//Якщо не вказувати значення для повернення, буде створений проміс зі значенням undefined.
{
  const foo = async () => {
    // Не вказуємо значення для повернення
  };

  foo().then((value) => {
    console.log(value); // undefined
  });
}
// Оскільки нічого не повертається, результатом буде Promise.resolve(undefined).
// Асинхронні функції спрощують роботу з промісами, дозволяючи уникнути вкладених .then() і роблячи код читабельнішим.
//#endregion

//#region Оператор await

// Оператор await використовується всередині асинхронних функцій (async) для очікування завершення промісу перед тим, як виконання коду продовжиться.

/* Коли інтерпретатор зустрічає await:

Виконання функції призупиняється до завершення промісу.
Якщо проміс виконано успішно (fulfilled), await повертає його значення.
Якщо проміс відхилено (rejected), виникає помилка. */
{
  const foo = async () => {
    console.log("Before await");

    const promiseValue = await new Promise((resolve) => {
      setTimeout(() => resolve(5), 2000);
    });

    console.log("After await", promiseValue);
  };

  foo(); // через 2 секунди виведеться в консоль  "After await" 5
}

/* Що відбувається в коді?

console.log("Before await") виконується синхронно.
Інтерпретатор зустрічає await та призупиняє виконання функції foo(), чекаючи завершення промісу.
Через 2 секунди проміс виконується (resolve(5)), і його значення (5) зберігається у змінній promiseValue.
Код після await продовжує виконуватися. */

/* Основні правила використання await

await можна використовувати тільки всередині асинхронних функцій (async).
await не працює самостійно без async, але async може існувати без await.
await призупиняє виконання функції, доки проміс не завершиться.
Якщо проміс успішний, await повертає його значення.
Якщо проміс відхилено, await генерує помилку, яку потрібно обробляти через try/catch. */

/* Взаємозв’язок async та await

Асинхронна функція (async) завжди повертає проміс.
Будь-яке значення, що повертається з asyncфункції, автоматично обгортається в Promise.resolve().
Якщо функція не повертає значення, повернеться Promise.resolve(undefined). */

//Оператор await дозволяє писати асинхронний код у зрозумілішому стилі, уникнувши вкладених .then() і покращуючи читабельність.
//#endregion

//#region HTTP-запити
// Використання async/await при роботі з HTTP-запитами робить код більш читабельним і простішим у розумінні.

{
  // Перепишемо функцію fetchUsers з async/await. Спочатку розглянемо її у стандартному вигляді з axios і .then():
  const fetchUsers = () => {
    axios.get("https://jsonplaceholder.typicode.com/users").then((response) => {
      console.log(response.data);
    });
  };
}

//Додаємо async перед функцією:
{
  const fetchUsers = async () => {
    // ...
  };
}
//Використовуємо await, щоб зачекати завершення axios.get та отримати відповідь у змінну response:
{
  const fetchUsers = async () => {
    const response = await axios.get(
      "https://jsonplaceholder.typicode.com/users"
    );
    console.log(response.data);
  };
}

//Якщо отримані дані потрібно використовувати зовні, повертаємо їх із функції. Оскільки async-функція завжди повертає проміс, обробляємо результат через .then():
{
  const fetchUsers = async () => {
    const response = await axios.get(
      "https://jsonplaceholder.typicode.com/users"
    );
    return response.data;
  };

  fetchUsers().then((users) => console.log(users));
}

/* 
Чому async/await зручніше?

Запит виконується без вкладених .then().
Код виглядає послідовним, наче виконується синхронно.
Легше читати та дебажити

async/await робить роботу з HTTP-запитами зрозумілішою та зручнішою у порівнянні зі стандартним підходом на промісах. 
*/

//#endregion

//#region Конструкція try…catch

/* Конструкція try...catch використовується для обробки помилок, які можуть виникати під час виконання коду. Вона дозволяє:

Запобігати аварійному завершенню програми.
Логувати помилки та вживати відповідні заходи.
Повідомляти користувача про помилку. */
{
  try {
    // Код, у якому можуть виникнути помилки
  } catch (error) {
    // Код для обробки помилок, що виникли у блоці try
  }
}

/* Як працює try...catch?

Код у try виконується.
Якщо виникає помилка, подальше виконання try зупиняється, і програма переходить у catch.
Код у catch обробляє помилку, дозволяючи програмі продовжити роботу. */

{
  //Розглянемо приклад де ми намагаємося поділити число на нуль, що призводить до помилки. За допомогою try...catch можна перехопити цю помилку та вивести повідомлення про неї.
  console.log("Before try...catch");

  try {
    const result = 10 / 0;
    console.log(result); // Цей рядок не виконається через помилку
  } catch (error) {
    // Обробимо помилку
    console.error(error.message);
  }

  console.log("After try...catch");
}

/* Навіщо використовувати try...catch?

Без try...catch помилка може зупинити виконання всього коду.
З try...catch можна контролювати поведінку програми у разі помилки.


Ця конструкція часто використовується у роботі з промісами, async/await, та HTTP-запитами для безпечного виконання асинхронних операцій. */
//#endregion

//#region Обробка помилок

/* При використанні async/await помилки можуть виникати, якщо проміс відхилено (наприклад, сервер не відповідає або повертає помилку). Обробляти такі помилки можна двома способами:

Всередині асинхронної функції за допомогою try...catch.
Зовні через .catch() при виклику функції. */

{
  //1. Обробка помилок у самій функції (try...catch)

  // Якщо результат функції не використовується в зовнішньому коді, помилку потрібно обробляти прямо в її тілі.
  const fetchUsers = async () => {
    try {
      const response = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      console.log(response.data);
    } catch (error) {
      console.log("Помилка при отриманні користувачів:", error);
    }
  };

  //Якщо проміс відхилено, await генерує помилку, яка передається у catch.
}

{
  //2. Обробка помилок у .catch() зовні

  //Якщо результат повертається з асинхронної функції, обробка помилки виконується у .catch() при виклику цієї функції.
  const fetchUsers = async () => {
    const response = await axios.get(
      "https://jsonplaceholder.typicode.com/users"
    );
    return response.data;
  };

  fetchUsers()
    .then((users) => console.log(users))
    .catch((error) => console.log("Помилка:", error));

  //У цьому випадку помилка, згенерована await, відхиляє проміс, і вона перехоплюється у .catch().
}

{
  //3. Обробка помилок в іншій асинхронній функції (try...catch)

  // Якщо асинхронна функція викликається в іншій async-функції, обробка відбувається через try...catch.
  const fetchUsers = async () => {
    const response = await axios.get(
      "https://jsonplaceholder.typicode.com/users"
    );
    return response.data;
  };

  const doStuff = async () => {
    try {
      const users = await fetchUsers();
      console.log(users);
    } catch (error) {
      console.log("Помилка в doStuff:", error);
    }
  };

  doStuff();

  //Помилка fetchUsers() буде перехоплена у catch функції doStuff().
}

/* Коли який підхід використовувати?

try...catch у функції – коли потрібно обробити помилку локально.
.catch() зовні – коли асинхронна функція повертає проміс, а обробку виконує зовнішній код.
try...catch у asyncфункції – коли виклик відбувається всередині іншої асинхронної функції. */
// #endregion
