//Модульність коду

// #region Модульність коду
// Концепція модулів як способу організації коду існувала давно. Зі збільшенням проєкту і його кодової бази, її намагаються розбити на файли, у кожному з яких описується окремий функціонал. Модульний код допомагає в організації, обслуговуванні, тестуванні і, найголовніше, управлінні залежностями.

// Найважливіші переваги модулів:
// Підтримка — добре розроблений модуль покликаний максимально зменшити залежність від інших частин коду. Використання модулів дозволяє розширювати функціонал застосунку з мінімальним ризиком порушити його роботу в цілому. Оновлення одного модуля набагато простіше, якщо модуль самодостатній.
// Простір імен — змінні, що не входять в область видимості функції, є глобальними. Внаслідок цього, як правило, відбувається забруднення простору імен, де повністю непов'язаний код розділяє глобальні змінні. Модулі дозволяють уникнути забруднення простору імен, створюючи окрему область видимості для змінних.
// Повторне використання — усі розробники копіювали готовий код у нові проєкти, змінюючи його під специфіку проєкту. Але це величезна трата часу. Набагато краще, коли є модуль, який можна повторно використовувати знову і знову, без необхідності знати що-небудь про оточення, в якому він використовується.
//#endregion

//#region ECMAScript модулі
// ECMAScript Modules (ESM) — сучасний стандарт системи модулів JavaScript, який відповідає за організацію та уніфікований підхід до імпорту та експорту даних між різними файлами в проєкті.

// Модуль — це JavaScript-файл із фрагментом коду, який можна використовувати багато разів. Модуль експортує певні об'єкти, зробивши їх доступними для інших модулів.

// У прикладі нижче файл makeMessage.js оголошує та експортує функцію для створення повідомлення за іменем користувача.
/*
{
  export default function makeMessage(username) {
    return `Welcome, ${username}!`;
  }
}
*/

//Функцію, яку експортує модуль makeMessage.js, можна використовувати у будь-якому іншому файлі проєкту, наприклад, у index.js.
/*
{
  import makeMessage from "./makeMessage";

  console.log(makeMessage("Jacob")); // "Welcom, Jacob!"
}
*/

//Кожен JavaScript-файл зберігає код в унікальному контексті модуля, імпортує необхідні йому залежності та експортує все, що інші модулі можуть імпортувати. Далі ми детально розглянемо синтаксис експорту/імпорту.
// З часом ECMAScript Modules (ESM) буде повністю підтримуватися браузерами нативно, без потреби додаткових інструментів. Проте на даний момент браузерна підтримка ще не повністю реалізована, тому ESM часто використовується спільно з інструментами для збірки модулів, такими як Vite, який дозволяє це робити без додаткової конфігурації.

//#endregion

//#region Експорт та імпорт за замовчуванням
// Основна ідея полягає в тому, що в одному модулі може бути лише один експорт за замовчуванням (default export). Це значення вважається "головним" значенням модуля, коли його імпортують в інші частини коду.

//Операція експорту за замовчуванням реалізована конструкцією export default.
// Де:
// export default — ключова фраза для експорту;
// exportedValue — значення, яке експортується.
// Ось так виглядає синтаксис для експорту значення за замовчуванням.
/*
{
  const makeMessage = (username) => {
    return `Welcome, ${username}!`;
  };

  export default makeMessage;
}
*/
//#endregion

//#region Іменовані експорт та імпорт
// Іменований експорт (named export) — це спосіб експортування одного або кількох значень з модуля під конкретними іменами.
// За допомогою іменованого експорту можна отримати доступ до будь-якого значення: змінної, функції або об'єкта тощо під певним ім'ям. Пізніше ці значення можна імпортувати в іншому файлі за допомогою цього самого імені.
// Операція іменовано,0го експорту реалізована конструкцією з export.

//#endregion

//#region Перейменування
// Rename export — це техніка, яка дозволяє імпортувати іменовані експортовані змінні, функції тощо з одного модуля до іншого, змінюючи їм ім’я під час імпорту.
/*
{
  // Щоб задати нове ім'я під час імпорту з іншого модуля, використовується ключове слово as.

  // Module myModule.js
  export const original = "Hello, World!";

  // Your current module, for example app.js
  import { original as renamed } from "./myModule.js";

  console.log(renamed); // "Hello, World!"
}
*/
// #endregion

//#region Імпорт простору імен
// Імпорт простору імен (namespace import) — це техніка імпортування всього вмісту модуля як об'єкта з іменем, що представляє простір імен цього модуля. Це означає, що всі іменовані експорти з модуля стають властивостями цього об'єкта. Це зручно, коли потрібно імпортувати багато різних функцій, змінних або класів з модуля, не обираючи їх по одному.

// Module user.js
export const name = "Mango";
export const age = 26;
export const email = "mango@mail.com";

// Your current module
import * as user from "./myModule.js";

console.log(user.name); // "Mango"
console.log(user.age); // 26
console.log(user.email); // "mango@mail.com"

//У цьому прикладі ми імпортуємо всі іменовані експорти з модуля user.js як об'єкт user. Усі іменовані експорти стають властивостями цього об'єкта. В результаті ми можемо звертатися до них через крапку.
// Імпорт простору імен дозволяє уникнути конфліктів імен між імпортованими об'єктами та іменами у твоєму поточному модулі. Це особливо корисно, коли ти працюєш з бібліотеками або модулями, де є багато іменованих експортів.
// #endregion
