//#region Стандарт JSON

// JSON (JavaScript Object Notation) — сучасний текстовий формат зберігання й передачі структурованих даних у текстовій формі. Саме в цьому форматі дані будуть приходити і відправлятися на сервер, зберігатися в локальному сховищі тощо.
// Звичайний об'єктоподібний синтаксис JSON дуже зручний. Але JSON — це не об'єкт, а його рядкове відображення. Розгляньте приклад JSON файлу.

//{
//"name": "Josh",
//"weight": 175,
//"age": 30,
//"eyecolor": "brown",
//"isHappy": true,
//"cars": ["Chevy", "Honda"],
//"favoriteBook": {
//"title": "The Last Kingdom",
//"author": "Bernard Cornwell",
//"rating": 8.38
//}
//}

//Синтаксис схожий на об'єкт, за винятком того, що:
// Ключі — це завжди рядки, обов'язково в подвійних лапках.
// Значення рядків — також обов'язково в подвійних лапках.
// Числа можуть бути цілими або десятковими, з десятковою крапкою або без неї, включаючи негативні.
// Числа та булеві значення true і false записуються так само, як у JavaScript.
// У JSON немає коми після останньої властивості об'єкта.
// Значення властивостей може бути спеціальним значенням null, але не може бути undefined.
// Функції не можна зберігати у JSON, оскільки JSON передбачений лише для даних, а не для методів обробки даних.

//#endregion

//#region Перетворення у json
// Javascript і JSON чудово працюють разом, завдяки методам вбудованого класу JSON. Ці методи перетворюють JavaScript об'єкт у JSON і навпаки.
// Метод JSON.stringify(value) приймає значення і перетворює його у JSON. Значенням може бути число, буль, null, масив, об'єкт.
// Рядки — це вже валідний JSON, тому в їх перетворенні немає сенсу.

{
  const dog = {
    name: "Mango",
    age: 3,
    isGoodBoy: true,
  };

  const json = JSON.stringify(dog);
  console.log(json); // '{"name":"Mango","age":3,"isGoodBoy":true}'
}

//Результат виклику JSON.stringify — це валідний JSON (рядок), який може бути збережений у вебсховище, базу даних або переданий мережею на сервер.

//#endregion

//#region  Перетворення функцій
// Не всі JavaScript об'єкти можуть бути перетворені один в один у JSON. Наприклад, якщо в об'єкта є методи, то при перетворенні вони будуть проігноровані та не потраплять у JSON.
{
  const dog = {
    name: "Mango",
    age: 3,
    isGoodBoy: true,
    bark() {
      console.log("Woof!");
    },
  };

  const json = JSON.stringify(dog);
  console.log(json); // '{"name":"Mango","age":3,"isGoodBoy":true}'
}
{
  //Також при спробі перетворити функцію у JSON результатом буде undefined.
  const json = JSON.stringify(() => console.log("Well, this is awkward"));
  console.log(json); // undefined
}
//#endregion

//#region Парсинг із json
// Щоб отримати з JSON валідне JavaScript значення, його необхідно розпарсити (parse). Це операція зворотня перетворенню JavaScript об'єкта в json за допомогою методу JSON.stringify(value)

// Метод JSON.parse(value) приймає json, тобто рядок, і перетворює його у JavaScript дані.
{
  console.log(JSON.parse("5")); // 5
  console.log(JSON.parse("false")); // false
  console.log(JSON.parse("null")); // null
}
//Якщо json описує складний тип даних, наприклад об'єкт, то в результаті отримаємо валідний об'єкт, з яким можна працювати звичайним чином.
{
  const json = '{"name":"Mango","age":3,"isGoodBoy":true}';

  const dog = JSON.parse(json);
  console.log(dog); // {name: "Mango", age: 3, isGoodBoy: true}
  console.log(dog.name); // "Mango"
}

//#endregion

//#region Обробка помилок

// Якщо методу JSON.parse передати невалідний JSON, він згенерує помилку. Як результат, увесь скрипт впаде, тобто припинить своє виконання, і весь код після місця помилки не виконається.
// До такого сценарію призведе, наприклад, парсинг рядка.
// Рядок із символами — це невалідний JSON, адже він не може бути перетворений у валідне JavaScript значення.
{
  //const data = JSON.parse("Well, this is awkward");
  //console.log("❌ You won't see this log");
}

//Помилка буде і при спробі парсингу невалідного об’єкта, який, наприклад, може прийти з бекенду. У прикладі у властивості username бракує подвійних лапок.
{
  //const data = JSON.parse('{username: "Mango"}'); // Error
  //console.log("❌ You won't see this log");
}

//#endregion

//#region Рішення
// Для уникнення цього використовується конструкція try...catch, яка дозволяє «ловити» й обробляти помилки виконання скрипта.
{
  try {
    // Code that may throw a runtime error
  } catch (error) {
    // Error handling
  }
}

//Спочатку виконується код всередині блоку try.
// Якщо помилки відсутні, блок catch ігнорується й управління передається далі.
// Якщо в блоці try сталася помилка, його виконання зупиняється та інтерпретатор переходить до блоку catch.

//Використовуючи конструкцію try...catch, можна обробити цей виняток таким чином, щоб скрипт за межами цієї конструкції продовжив працювати, навіть у разі помилки.
{
  try {
    const data = JSON.parse("Well, this is awkward");
  } catch (error) {
    console.log(error.name); // "SyntaxError"
    console.log(error.message); // Unexpected token W in JSON at position 0
    console.log(error.stack); //
  }
  console.log("✅ This is fine, we handled parsing error in try...catch");
}

//Змінна error — це об'єкт помилки з інформацією про те, що сталося.

// У цього об'єкта є кілька корисних властивостей:

// name — тип помилки. Для помилки парсингу — це SyntaxError.
// message — повідомлення про деталі помилки.
// stack — стек викликів функцій на момент помилки. Використовується для налагодження.//

//#endregion

//#region Детальніше про помилки

// У JavaScript код виконується не одразу.
// Для початку інтерпретатору потрібно прочитати код і дізнатися, чи можливо його взагалі виконати.

//Фаза інтерпретації, або оцінки (compile time, evaluation time) — підготовка перед виконанням коду: інтерпретатор знаходить синтаксичні помилки, помилки типізації тощо. Отже, код ще не виконується, лише оціняється.
//Якщо ця фаза пройшла успішно, це щонайменше означає, що в коді відсутні синтаксичні помилки і його можна запустити для виконання.

//Фаза виконання (runtime) — скрипт починає виконуватися: виконуються інструкції викликів функцій і оцінювання виразів, відбувається пошук необхідних ідентифікаторів у відповідних областях видимості тощо.
// Якщо ця фаза проходить успішно, це свідчить про те, що скрипт написаний без явних помилок і виконав свою роботу. На цій фазі можуть бути помилки, пов'язані з відсутніми властивостями та змінними, перетворенням типів тощо, тобто щось, що відбувається тільки під час виконання коду.

{
  //console.log('This message will not appear in the console');
  //cos value = 5;
}

//У ньому навмисно зроблена помилка. Замість const намагаємося оголосити змінну value ключовим словом cos. На фазі оцінки буде виявлена синтаксична помилка. Фаза виконання навіть не запуститься. У консолі ми одразу побачимо повідомлення про помилку.
// Конструкція try...catch ловить тільки помилки, які виникли під час виконання коду (runtime errors). Це означає, що код має бути синтаксично правильним, інакше фаза виконання просто не запуститься. Помилки, які виникають під час фази оцінювання, називаються помилками парсингу.

//#endregion
