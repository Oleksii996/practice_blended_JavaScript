//Вебсховище

//#region Сookie;

// Скільки разів тобі зустрічалося спливаюче вікно на вебсайті з написом:
// Цей вебсайт використовує файли cookie для зберігання вашої інформації.

// Скоріш за все, так часто, що можна збитися з рахунку!

// Свого часу вебсайти використовували протокол HTTP без збереження стану. Це означало, що вони не могли зберігати інформацію, пов’язану з користувачем, таку як ідентифікатор сеансу користувача, ім’я користувача, наповнення кошика товарів тощо, у веббраузері.

// З розвитком інтернету та його популярністю вебсайти почали зберігати інформацію, пов’язану з користувачем, у самому браузері. Це допомогло розрізняти тип користувача, який взаємодіє з їхнім вебсайтом, і забезпечити персоналізований досвід для користувача.

//Так з’явилися cookie (кукі). Вони надали механізм для зберігання невеликих фрагментів текстових даних клієнта або сервера у браузері як пари ключ-значення. Сookie також мають позначку часу закінчення терміну їх дії, після чого автоматично видаляються браузером.

// Браузер і сервер можуть установлювати та отримувати cookie з браузера користувача. Крім того, cookie можуть автоматично надсилатися разом із кожним HTTP-запитом на сервер. У результаті сервер може легко розпізнати інформацію користувача з кожним HTTP-запитом, який зробив користувач.

// Сookie використовуються й досі, але взаємодія з ними часто зводиться до встановлення та читання їх значень на сервері. Зазвичай це робиться за допомогою різних бібліотек, щоб спростити весь процес.

// Фронтенд рідко взаємодіє із вмістом cookie безпосередньо, оскільки вони можуть бути дещо обмеженими у використанні та мати обмежену ємність для зберігання даних. Щоб вирішити цю проблему, сучасні браузери мають власні механізми зберігання, такі як локальне сховище та сховище сеансів.

//#endregion

//#region Web Storage API

//Cookie розв'язують проблему збереження інформації на стороні користувача під час взаємодії з вебсайтами. Водночас вони мають деякі обмеження.
// По-перше, їхні можливості обмежуються зберіганням даних розміром лише до кількох кілобайт. З ростом складності клієнтських програм виникла потреба зберігати більш об'ємні та складні дані прямо у браузері.
// З появою HTML5 на вебсайтах з'явилося API зберігання даних у браузері для ефективного управління інформацією на стороні користувача. Таким чином, будь-який JavaScript-код, що запускається у браузері, може легко отримати доступ до цих API. Основна відмінність полягає в тому, що ці механізми надавали більший об'єм для зберігання даних і можуть бути доступні лише для JavaScript, що виконувався на боці клієнта.

//Вебсховище — це механізм у веббраузерах, який дозволяє вебдодаткам зберігати та отримувати дані на стороні клієнта, тобто на комп'ютері користувача. Щоразу, коли ти змінюєш тему кольорів між світлою і темною, переглядаєш відео, додаєш товар у кошик, відкриваєш або закриваєш сайдбар, популярні вебзастосунки можуть запам'ятовувати стан інтерфейсу і в наступному відвідуванні відновлювати його.
// Вебсховище не зберігає паролі, номери банківських карт та іншу конфіденційну інформацію. Якщо шкідливий скрипт отримає доступ до вебсторінки, він без проблем зможе прочитати ці дані.
// Вебсховище складається з локального сховища та сховища сеансів.
// Локальне сховище (Local Storage): унікальне для кожного вебдодатку і буде однаковим на кількох вкладках, де вебдодаток відкритий. Дані в локальному сховищі не видаляються, навіть після закриття браузера або вимкнення комп'ютера. Щоб їх видалити, потрібно використовувати JavaScript. Доступ до даних у локальному сховищі можливий з будь-якої вкладки або вікна браузера, пов'язаної з доменом, який створив дані.
// Сховище сесії (Session Storage): на відміну від локального сховища, дані у сховищі сесії зберігаються лише протягом одної сесії браузера. Якщо користувач закриє вкладку або браузер, дані будуть видалені. Сховище сесії зручне для зберігання тимчасових даних або станів, які не повинні зберігатися довгий час.

//#endregion

//#region Локальне сховище
// Дані в локальному сховищі зберігаються у JSON форматі під певним ключем. Цей ключ може бути тільки рядком, і значенням виступає будь-що, що дозволяється JSON форматом.
// Локальне сховище може зберігати дані розміром від 5 Мб до 10 Мб. Точний обсяг пам’яті залежить від реалізації кожного браузера, але це значно більше, ніж 4 Кб пам’яті, яку пропонують cookie.
// Дані в локальному сховищі не мають терміну зберігання за замовчуванням. Вони видаляються, лише якщо ти вручну видалиш ці дані з локального сховища безпосередньо, через налаштування браузера або за допомогою коду JavaScript. Це означає, що дані в локальному сховищі зберігаються навіть після закриття певної вкладки або вікна браузера. У кожного сайту своє окреме локальне сховище, тому збережені дані між сайтами не перетинаються.
// Доступ до локального сховища можна отримати в об’єкті window:

console.log(window.localStorage);
// Storage {length: 0}

//Це поверне довжину локального сховища разом з об’єктом, що представляє дані, які зараз присутні всередині. Оскільки спочатку він порожній, довжина дорівнює 0.
// Можна також отримати прямий доступ до об’єкта localStorage, адже за замовчуванням пошук відбувається на об’єкті window.

console.log(localStorage);
// Storage {length: 0}

//Завдяки тому, що дані в локальному сховищі не мають терміну зберігання за замовчуванням, цей тип сховища має цілу низку застосувань. Це всі ті сценарії, коли потрібно зберігати деякі глобальні дані, до яких часто звертаються у програмі.
// Наприклад, зміна теми кольорів між світлою і темною, перегляд відео, додавання товару в кошик, відкривання або закривання сайдбара, бажаний спосіб оплати користувача, адреси доставки за замовчуванням тощо, увесь цей стан інтерфейсу можливо зберегти і в наступному відвідуванні відновити його.

//#endregion

//#region Додавання даних
//Давай додамо пару ключ-значення до локального сховища за допомогою методу setItem(key, value), доступного в об’єкті localStorage:
{
  localStorage.setItem("ui-theme", "light");
  console.log(localStorage); // Storage {ui-theme: "light", length: 1}
}
//А що як у сховищі вже існував запис із ключем "ui-theme"?
// Виклик методу setItem(key, value) перезапише його значення.
//#endregion

//#region Додавання складних даних

// У вебсховище не записують методи об'єктів або функції, тільки дані, які підтримує JSON формат.
// Технічно у вебсховище можна записати тільки рядки. Але це не проблема, якщо використовувати методи класу JSON для перетворення складних типів.
// Якщо необхідно зберегти щось, окрім рядка, наприклад, масив або об'єкт, необхідно перетворити їх у рядок методом JSON.stringify().
{
  const settings = {
    theme: "dark",
    isAuthenticated: true,
    options: [1, 2, 3],
  };

  localStorage.setItem("settings", JSON.stringify(settings));
}
//#endregion

//#region Отримання даних

// Метод getItem(key) дозволяє зчитати зі сховища запис із ключем key і повертає його значення у JSON форматі.
{
  const savedTheme = localStorage.getItem("ui-theme");
  console.log(savedTheme); // "light"
}

//Якщо у сховищі відсутній запис з таким ключем, метод повертає null.
{
  const savedItem = localStorage.getItem("key-that-does-not-exist");
  console.log(savedItem); // null
}

//Якщо значення є примітивним типом, немає потреби його парсити.
// В іншому випадку, якщо це масив або об'єкт, необхідно розпарсити значення методом JSON.parse(), щоб отримати валідні дані.
{
  const settings = {
    theme: "dark",
    isAuthenticated: true,
    options: [1, 2, 3],
  };
  localStorage.setItem("settings", JSON.stringify(settings));

  const savedSettings = localStorage.getItem("settings");
  console.log(savedSettings); // A string

  const parsedSettings = JSON.parse(savedSettings);
  console.log(parsedSettings); // Settings object
}
//У змінній savedSettings буде рядок, що представляє об'єкт, тому ми розпарсюємо це значення, і у змінній parsedSettings отримуємо повноцінний об'єкт із властивостями.
//#endregion

//#region Видалення даних
// Метод removeItem(key) видаляє зі сховища існуючий запис з ключем key. В результаті своєї роботи він не повертає значення.
{
  localStorage.setItem("ui-theme", "dark");
  console.log(localStorage.getItem("ui-theme")); // "dark"

  localStorage.removeItem("ui-theme");
  console.log(localStorage.getItem("ui-theme")); // null
}

//Якщо ти хочеш повністю очистити сховище, потрібно викликати метод clear().
{
  localStorage.setItem("ui-theme", "light");
  localStorage.setItem("notif-level", "mute");

  console.log(localStorage);
  // Storage {notif-level: 'mute', ui-theme: 'light', length: 2}

  localStorage.clear();
  console.log(localStorage); // Storage {length: 0}
}
//Операція повного очищення сховища є ризикованою. Вона може порушити записи, створені іншими розробниками проєкту. Краще видаляти лише ті записи, які дійсно не потрібні, не покладаючись на повну очистку даних сховища.
//#endregion

//#region Сховище сесії
// Сховище сесії зберігає дані лише доти, поки відкрита вкладка браузера.
// Це означає, що кожного разу, коли відкривається нова вкладка або нове вікно браузера, створюється нове сховище сесії. Отже, будь-які дані, які зберігаються в сховищі сесії, автоматично видаляються, коли користувач закриває цю вкладку/вікно.

// Набір методів та їхній функціонал ідентичні методам роботи з локальним сховищем.
// Єдиний виняток — звертаємося до них через об'єкт sessionStorage, а не localStorage.

console.log(window.sessionStorage); // Storage {length: 0}

//Методом setItem(key, value) можна записувати як рядки, так і складні типи даних.
{
  sessionStorage.setItem("user-id", "123");
  sessionStorage.setItem(
    "tickets",
    JSON.stringify({ from: "Lviv", to: "Kyiv", quantity: 2 })
  );
  console.log(sessionStorage);
  // Storage {user-id: '123', tickets: '{"from":"Lviv","to":"Kyiv","quantity":2}', length: 2}
}

//Методом getItem(key) можна читати записи, використовуючи збережений ключ.
{
  const userId = sessionStorage.getItem("user-id");
  console.log(userId); // "123"

  const tickets = JSON.parse(sessionStorage.getItem("tickets"));
  console.log(tickets); // { from: "Lviv", to: "Kyiv", quantity: 2 }
}

//І звісно, видаляти елементи за ключем і очищати сховище цілком методами removeItem(key) і clear() відповідно.
{
  sessionStorage.removeItem("tickets");
  console.log(sessionStorage); // Storage {user-id: '123', length: 1}

  sessionStorage.clear();
  console.log(sessionStorage); // Storage {length: 0}
}
//#endregion

//#region Кейс: Форма з повідомленням
// Створимо форму для введення повідомлення.
//Під час сабміту форми будемо виводити в консоль значення текстового поля та очищати форму.
{
  const form = document.querySelector(".feedback-form");

  form.addEventListener("submit", (evt) => {
    evt.preventDefault();
    console.log(evt.target.elements.message.value);
    form.reset();
  });
}

//Проблема
// Якщо користувач ввів повідомлення в текстове поле і перезавантажив сторінку, не надіславши форму, під час перезавантаження сторінки введене повідомлення пропадає.

//Рішення
// Зробимо так, щоб при перезавантаженні сторінки зберігалося введене повідомлення.
// Для цього використовуємо локальне сховище, щоб зберегти поточне значення текстового поля під час введення.
{
  const form = document.querySelector(".feedback-form");
  const localStorageKey = "goit-example-message";

  form.addEventListener("input", (evt) => {
    localStorage.setItem(localStorageKey, evt.target.value);
  });

  form.addEventListener("submit", (evt) => {
    evt.preventDefault();
    console.log(evt.target.elements.message.value);
    form.reset();
  });
}

//Щоразу, коли змінюється значення поля, тобто відбувається подія "input", ми:
// використовуємо делегування подій;
// ловимо подію на формі;
// використовуємо властивість target для запису поточного значення поля в локальне сховище.

//Під час сабміту форми будемо очищати збережене значення методом removeItem.
{
  const form = document.querySelector(".feedback-form");
  const localStorageKey = "goit-example-message";

  form.addEventListener("input", (evt) => {
    localStorage.setItem(localStorageKey, evt.target.value);
  });

  form.addEventListener("submit", (evt) => {
    evt.preventDefault();
    console.log(evt.target.elements.message.value);
    localStorage.removeItem(localStorageKey);
    form.reset();
  });
}

//Останнім кроком необхідно додати код читання збереженого повідомлення з локального сховища і встановлення його початковим значенням для текстового поля під час завантаження сторінки.
{
  const form = document.querySelector(".feedback-form");
  const textarea = form.elements.message;
  const localStorageKey = "goit-example-message";

  textarea.value = localStorage.getItem(localStorageKey) ?? "";

  form.addEventListener("input", (evt) => {
    localStorage.setItem(localStorageKey, evt.target.value);
  });

  form.addEventListener("submit", (evt) => {
    evt.preventDefault();
    console.log(evt.target.elements.message.value);
    localStorage.removeItem(localStorageKey);
    form.reset();
  });
}

//#endregion
